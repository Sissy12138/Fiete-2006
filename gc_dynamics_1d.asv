function gc_dynamics_1d(periodic,N)
%network parameters
m = 4;              %CV = 1/sqrt(m) 将一个时间步细分为m个间隙累计poisson事件，
x_prefs = (1:N)'/N; %inherited location preferences (m)
                    % 每个神经元内置的位置偏好


%FeedForward input 包括速度输入增益，基线输入，突触形状参数
beta_vel = 1.5;     %velocity gain
beta_0 = 70;        %uniform input
alpha = 1000;        %weight imbalance parameter
gamma = 1.05/100;    %Cennter Surround weight params
beta = 1/100;        %Cennter Surround weight params

%temporal parameters

T = 100;            %length of integration time blocks (s)
dt = 1/2000;        %step size of numerical integration (s)
tau_s = 30/1000;    %synaptic time constant (s)


%Graphing parameters 绘图
bins = linspace(0+.01,1-.01,50);
scrsz = get(0,'ScreenSize');
figure('Position',[500 scrsz(4)/2 scrsz(3)*(3/4) scrsz(4)/2])

% Trajectory Data (Sinusoidal)
x = (sin((dt:dt:T)*2*pi/10)+1)/2;  % generate 正弦波
v= zeros(1,T/dt);                  % 初始化速度并计算每一步速度
for i = 2:T/dt
    v(i) = (x(i)-x(i-1))/dt;
end

z = (-N/2:1:N/2-1);    % 相对索引，用于构造权重函数

% Feed forward network input   (!!!这里可能写反了？)
if periodic == 0
    % gaussian FF input for aperiodic network
    envelope = exp(-4*(z'./(N/2)).^2);  
else
    envelope = ones(N,1);
end

% 记录群体神经元活动
s_prev = zeros(2*N,1);  %Population activity
spk = zeros(2*N,T/dt);  %Total spiking
spk_count = zeros(2*N,1); %Current spiking

% Weight setup  
crossSection = alpha*(exp(-gamma*z.^2)-exp(-beta*z.^2)); % 注意alpha在括号外面，和文章里的公式不一样，所以永远都是抑制性输入！！！
% 对上一步生成的权重数组进行周期性平移
crossSection = circshift(crossSection, [0 N/2 - 1]);  % 这里的平移语法有点奇怪
% 这一步平移的目的是将bump移动到边界，方便下一步根据i为每个神经元生成
W_RR = zeros(N,N);
W_LL = zeros(N,N);
W_RL = zeros(N,N);
W_LR = zeros(N,N);

for i = 1:N
    % 这段代码把 crossSection 复制成 N 行，通过循环平移（circshift）得到每个神经元的连接权重
    % 对于第i个神经元，将crossSection平移到以i为中点，但是根据RR和LL进行微调
    % i-1说明左侧一个单位的神经元最大影响当前第i个神经元，信息向右传播
    W_RR(i,:) =  circshift(crossSection,[0 i - 1]); % Right neurons to Right neurons
    W_LL(i,:) =  circshift(crossSection,[0 i + 1]); % Left neurons to Left neurons
    % 以下两个保证两个群体的相互约束
    W_RL(i,:) =  circshift(crossSection,[0 i + 1]);     % Left neurons to Right neurons
    W_LR(i,:) =  circshift(crossSection,[0 i - 1]);     % Right neurons to Left neurons
end
% 要记住一共两类群体，分别定义内部投射和外部投射


for t = 2:T/dt

        %左右群体表示分别接收速度不同的调制，相当于对速度的tuning不同
        %LEFT population
        v_L = (1 - beta_vel*v(t)); % 速度越大，左侧输入反而小，但是速度为0有基础输入

        % s_prev分成两半，分别表示左向神经元活动和右向神经元活动
        g_LL = W_LL*s_prev(1:N);  % 左向神经元接收左向神经元输入%L->L
        % 左侧永远向左侧信息传递
        g_LR = W_LR*s_prev(N+1:2*N); % 到右侧的权重与另一半点乘%R->L
        % g_LL+g_LR得到左侧群体神经元接收到当前神经群体输入，被当前速度的输入调制
        % 当向右速度很快，v_L变成负值，G_L也是负值
        G_L = v_L*((g_LL + g_LR) + envelope*beta_0);              %input conductance into Left population
        % 速度输入
        %RIGHT population
        v_R = (1 + beta_vel*v(t));  % 速度正方向为右侧
        g_RR = W_RR*s_prev(N+1:2*N);                 %R->R
        % 这一步很重要，右群体的自连接促进信息向右流动
        g_RL = W_RL*s_prev(1:N);                     %L->R
        % 当向右活动时，右侧群体的兴奋性必然更强
        G_R = v_R*((g_RR + g_RL) + envelope*beta_0);              %input conductance into Right population
        
        G = [G_L;G_R];
        % 对左群体和右群体分别线性整流，小于0的设为0
        F = zeros(2*N,1) + G.*(G>=0);   %linear transfer function

        % subdivide interval m times
        % repmat：向维度1复制1次，维度2复制m次
        spk_sub = poissrnd(repmat(F,1,m)*dt); % 相当于做m次dt的泊松过程，并且将结果相加
        spk_count = spk_count+sum(spk_sub,2);
        % floor(spk_count/m) 取整，确定当前时间步实际发放几个脉冲
        spk(:,t) = floor(spk_count/m);
        spk_count = rem(spk_count,m); % 保留余数，累计信息避免脉冲数量一直为0

        %update population activity
        s_new = s_prev + spk(:,t) - s_prev*dt/tau_s;
        s_prev = s_new;


        if (mod(t,100)==0)%plot every 100 steps
            % 获取屏幕尺寸
            screen_size = get(0, 'ScreenSize');
            screen_width = screen_size(3);
            screen_height = screen_size(4);
            
            % 计算图形在中央的位置和大小
            fig_width = 800;  % 图形宽度
            fig_height = 600; % 图形高度
            left = (screen_width - fig_width) / 2;
            bottom = (screen_height - fig_height) / 2;
            
            % 设置当前图形窗口位置
            set(gcf, 'Position', [left, bottom, fig_width, fig_height]);
            subplot(2,2,1), h1=plot(x_prefs,W_RR(:,N/2),'r'), hold on, h2=plot(x_prefs,W_LL(:,N/2),'b'),legend('right','left'), hold off, title('Intra Connections of Typical Neurons')
            % subplot(2,2,1), h1=plot(x_prefs,W_RR(N/2,:),'r'), hold on, h2=plot(x_prefs,W_LL(N/2,:),'b'),legend('right','left'), hold off, title('Intra Connections of Typical Neurons')
            subplot(2,2,2), plot(x_prefs,F(1:N)), hold off,  title('Population Response of Left Population');
            subplot(2,2,4), plot(x_prefs,F(N+1:2*N)), hold off,  title('Population Response of right Population');
            subplot(2,2,3), plot(x_prefs,exp(-(x_prefs - x(t)).^2/.001^2)/max(exp(-(x_prefs - x(t)).^2/.001^2)),'g'), hold off, title('Position')
            % subplot(2,2,4), plot(bins,histc(x(1:t).*spk(N/2,1:t),bins)/dt./histc(x(1:t),bins)), title('SN Response')
            drawnow
        end

end


